---
title: Signal
description: Unified input abstraction with object pooling
---

Signal is an abstraction layer that transforms raw browser events into a unified, pooled data structure. It provides consistent input handling across different event types while preventing garbage collection overhead.

## What is a Signal?

A Signal wraps event data with:
- **Phase**: Lifecycle state (start, change, end, cancel)
- **Timestamp**: When the event occurred
- **Pooling**: Object reuse to prevent GC jank

## Signal Phase

All signals follow a consistent lifecycle:

| Phase | Description |
|-------|-------------|
| `start` | Input begins (finger down, mouse down) |
| `change` | Input is ongoing (movement) |
| `end` | Input completes normally (finger up) |
| `cancel` | Input interrupted (system gesture, focus loss) |

## SinglePointer Signal

The most common signal type, representing a single point of contact:

```typescript
import { singlePointer } from "@cereb/single-pointer";

const pointer$ = singlePointer(element);

pointer$.subscribe((signal) => {
  // signal.phase: "start" | "change" | "end" | "cancel"
  // signal.x, signal.y: coordinates
  // signal.pressure: 0.0 - 1.0
  // signal.pointerType: "mouse" | "touch" | "pen"
});
```

## Object Pooling

Signals use object pooling internally. During continuous input (like dragging), the same signal object is reused rather than creating new ones. This eliminates GC pauses during animations.

```typescript
// Internal pool management
const pool = createSignalPool<SinglePointer>(10);
const signal = pool.acquire(); // Get from pool
// ... use signal ...
pool.release(signal); // Return to pool
```

You typically don't need to manage pools directly - the library handles this automatically.
